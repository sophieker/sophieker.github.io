<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Local Video A/B Slider</title>
  <style>
    :root { --split: 50%; }
    html, body { height: 100%; }
    body { margin: 0; background:#0b0b0b; color:#e8e8e8; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; }
    .container {
      display: flex;
      height: 100vh;
      width: 100%;
    }
    .sidebar {
      width: 250px;
      background: #0f0f0f;
      border-right: 1px solid #2a2a2a;
      padding: 20px;
      overflow-y: auto;
      flex-shrink: 0;
    }
    .sidebar h2 {
      font-size: 16px;
      margin: 0 0 16px;
      color: #f2f2f2;
      font-weight: 600;
    }
    .video-option {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #e8e8e8;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    .video-option:hover {
      background: #252525;
      border-color: #3a3a3a;
    }
    .video-option.active {
      background: #2a3f4f;
      border-color: #4a8fc2;
    }
    .video-option .title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .video-option .description {
      font-size: 12px;
      opacity: 0.7;
    }
    .wrap { 
      flex: 1;
      height: 100vh; 
      padding: 16px; 
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    h1 { font-size: 18px; margin: 6px 0 12px; font-weight: 600; color: #f2f2f2; }
    .panel { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }
    .panel label { display: flex; align-items: center; gap: 8px; background: #1a1a1a; padding: 10px; border-radius: 10px; border: 1px solid #2a2a2a; }
    input[type="file"] { display: inline-block; max-width: 100%; }
    .player {
      position: relative; 
      width: 100%;
      flex: 1;
      background: #000; 
      overflow: hidden; 
      border-radius: 12px; 
      border: 1px solid #2a2a2a;
      max-height: calc(100vh - 150px);
      touch-action: none;
    }
    video {
      position: absolute; inset: 0; width: 100%; height: 100%;
      object-fit: contain;
      background: #000;
    }
    /* Top (right/B) video is clipped by the vertical wipe controlled by --split */
    .top {
      clip-path: polygon(0 0, var(--split) 0, var(--split) 100%, 0 100%);
      will-change: clip-path;
    }
    /* Slider bar */
    .slider {
      position: absolute; left: calc(var(--split) - 2px); top: 0; bottom: 0; width: 4px;
      background: #ffffffd0; box-shadow: 0 0 10px #000c; pointer-events: none;
    }
    /* Labels */
    .video-labels {
      position: absolute; top: 10px; left: 0; right: 0; 
      display: flex; justify-content: space-between; padding: 0 20px;
      pointer-events: none; z-index: 10;
    }
    .video-label {
      background: rgba(0,0,0,0.7); color: #fff; padding: 6px 12px;
      border-radius: 6px; font-size: 14px; font-weight: 600;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .video-label.left { background: rgba(0,80,120,0.8); }
    .video-label.right { background: rgba(120,60,0,0.8); }
    .codec-metrics {
      position: absolute; bottom: 10px; left: 0; right: 0;
      display: flex; justify-content: space-between; padding: 0 20px;
      pointer-events: none; z-index: 10;
    }
    .codec-metric {
      background: rgba(0,0,0,0.8); color: #fff; padding: 6px 12px;
      border-radius: 6px; font-size: 12px;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .codec-metric .value { font-weight: 600; color: #4ae; }
    .codec-metric.left { background: rgba(0,80,120,0.8); }
    .codec-metric.right { background: rgba(120,60,0,0.8); }
    .controls {
      display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-top: 10px;
    }
    .controls > * { background: #1a1a1a; border: 1px solid #2a2a2a; color: #eee; border-radius: 10px; padding: 8px 10px; }
    .controls button, .controls input[type="number"], .controls label { padding: 8px 10px; }
    .controls input[type="range"] { width: 220px; }
    .scrubber { flex: 1 1 300px; }
    .note { opacity: .75; margin-top: 8px; }
    .bad { color: #ffaaaa; }
    .good { color: #a6f3a6; }
    /* Toggle buttons for video sources */
    .source-toggles {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 10;
    }
    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      background: rgba(0,0,0,0.8);
      border-radius: 6px;
      padding: 2px;
    }
    .toggle-btn {
      padding: 4px 10px;
      background: transparent;
      border: none;
      color: #aaa;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
      min-width: 60px;
    }
    .toggle-btn.active {
      background: rgba(255,255,255,0.2);
      color: #fff;
    }
    .toggle-btn:hover:not(.active) {
      background: rgba(255,255,255,0.1);
      color: #ddd;
    }
    .toggle-group.left .toggle-btn.active { background: rgba(0,80,120,0.8); }
    .toggle-group.right .toggle-btn.active { background: rgba(120,60,0,0.8); }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h2>Select Video Pair</h2>
      <div style="margin-bottom: 12px; padding: 8px; background: #1a1a1a; border-radius: 6px; font-size: 12px; color: #888;">
        <strong>SimaUpscaleQ vs RealESRGAN</strong>
      </div>
      <div class="video-option active" data-video="koala_surfing">
        <div class="title">Koala Surfing</div>
        <div class="description">Koala on surfboard</div>
      </div>
      <div class="video-option" data-video="ocean_fire">
        <div class="title">Ocean Fire Show</div>
        <div class="description">Man spinning fire in front of ocean</div>
      </div>
      <div class="video-option" data-video="videoSRC21_07">
        <div class="title">Car Crash</div>
        <div class="description">High motion car crash sequence from SRC dataset</div>
      </div>
      <div style="margin: 16px 0 12px; padding: 8px; background: #1a1a1a; border-radius: 6px; font-size: 12px; color: #888;">
        <strong>SimaUpscaleF vs RealESRGAN</strong>
      </div>
      <div class="video-option" data-video="snow_scene_veo3">
        <div class="title">Snow Scene</div>
        <div class="description">A furry creature walking through a winter scene</div>
      </div>
      <div class="video-option" data-video="butterfly_mj">
        <div class="title">Butterfly</div>
        <div class="description">Video of butterfly in a woman's hands</div>
      </div>
      <div class="video-option" data-video="car">
        <div class="title">Car</div>
        <div class="description">High-quality car footage</div>
      </div>
      <div class="video-option" data-video="dancing">
        <div class="title">Dancing</div>
        <div class="description">Dynamic dancing scene</div>
      </div>
      <div class="video-option" data-video="goat">
        <div class="title">Goat</div>
        <div class="description">Mountain goat in natural habitat</div>
      </div>
      <div style="margin: 16px 0 12px; padding: 8px; background: #1a1a1a; border-radius: 6px; font-size: 12px; color: #888;">
        <strong>Deep vs. Standard Codec Comparison</strong>
      </div>
      <div class="video-option" data-video="deep_codec">
        <div class="title">Bees</div>
        <div class="description">Deep: 39.59 dB PSNR @ 216 kbps<br>Standard: 39.12 dB PSNR @ 605 kbps</div>
      </div>
      <div class="video-option" data-video="deep_codec_waves">
        <div class="title">Waves</div>
        <div class="description">Deep: 34.8 dB PSNR @ 1364 kbps<br>Standard: 33.9 dB PSNR @ 2836 kbps</div>
      </div>
    </div>
    <div class="wrap">
    <h1>RealESRGAN vs SimaUpscaleQ â€” Video Quality Comparison</h1>

    <div class="panel" style="display: none;">
      <label>Left (A)
        <input id="fileA" type="file" accept="video/mp4,video/webm,video/ogg" />
      </label>
      <label>Right (B)
        <input id="fileB" type="file" accept="video/mp4,video/webm,video/ogg" />
      </label>
    </div>

    <div class="player" id="player">
      <video id="vidA" class="bottom" preload="auto" muted playsinline></video>
      <video id="vidB" class="top" preload="auto" muted playsinline></video>
      <div class="slider" aria-hidden="true"></div>
      <div class="source-toggles" id="sourceToggles" style="display:none;">
        <div class="toggle-group left">
          <button class="toggle-btn active" data-side="left" data-source="simaf">SimaF</button>
          <button class="toggle-btn" data-side="left" data-source="resr">RealESR</button>
          <button class="toggle-btn" data-side="left" data-source="lr">Input LR</button>
        </div>
        <div class="toggle-group right">
          <button class="toggle-btn" data-side="right" data-source="simaf">SimaF</button>
          <button class="toggle-btn active" data-side="right" data-source="resr">RealESR</button>
          <button class="toggle-btn" data-side="right" data-source="lr">Input LR</button>
        </div>
      </div>
      <div class="video-labels" id="videoLabels" style="display:none;">
        <span class="video-label left" id="leftLabel">SimaUpscaleQ</span>
        <span class="video-label right" id="rightLabel">RealESRGAN</span>
      </div>
      <div class="codec-metrics" id="codecMetrics" style="display:none;">
        <span class="codec-metric left" id="leftMetric"></span>
        <span class="codec-metric right" id="rightMetric"></span>
      </div>
    </div>

    <div class="controls">
      <button id="playPause" disabled>Play</button>
      <label>Reveal B
        <input id="split" type="range" min="0" max="100" value="50" />
      </label>
      <input id="seek" class="scrubber" type="range" min="0" max="1000" value="0" />
      <span id="timeLabel">00:00 / 00:00</span>
      <label>Rate
        <input id="rate" type="number" step="0.25" min="0.25" max="4" value="1" />
      </label>
      <label><input id="loop" type="checkbox" checked /> Loop</label>
      <span id="status"></span>
    </div>

    <p class="note">
      Drag anywhere on the video to move the divider. Use keyboard shortcuts: Space to play/pause, arrow keys to seek.
    </p>
    </div>
  </div>

  <script>
    const root   = document.documentElement;
    const player = document.getElementById('player');
    const vidA   = document.getElementById('vidA');
    const vidB   = document.getElementById('vidB');
    const fileA  = document.getElementById('fileA');
    const fileB  = document.getElementById('fileB');

    const playPause = document.getElementById('playPause');
    const split     = document.getElementById('split');
    const seek      = document.getElementById('seek');
    const timeLabel = document.getElementById('timeLabel');
    const rate      = document.getElementById('rate');
    const loop      = document.getElementById('loop');
    const status    = document.getElementById('status');

    // State
    let aReady = false, bReady = false;
    let dragging = false;
    let syncing = false;

    function setSplit(pct) { root.style.setProperty('--split', pct + '%'); }
    setSplit(split.value);

    split.addEventListener('input', () => setSplit(split.value));

    function updateSplitFromEvent(e) {
      const rect = player.getBoundingClientRect();
      const x = Math.min(Math.max(e.clientX - rect.left, 0), rect.width);
      const pct = 100 * x / rect.width;
      setSplit(pct);
      split.value = Math.round(pct);
    }

    player.addEventListener('pointerdown', (e) => { 
      dragging = true; 
      updateSplitFromEvent(e);
      // Pause sync while dragging to prevent conflicts
      if (!vidA.paused) {
        syncing = false;
      }
    });
    window.addEventListener('pointermove', (e) => { 
      if (dragging) updateSplitFromEvent(e); 
    });
    window.addEventListener('pointerup', () => { 
      dragging = false;
      // Resume sync after dragging
      if (!vidA.paused) {
        // Force hard sync after drag
        vidB.currentTime = vidA.currentTime;
        syncing = true;
      }
    });

    function formatTime(s) {
      const m = Math.floor(s / 60); const ss = Math.floor(s % 60);
      return `${m.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
    }

    // Keep UI time display fresh
    let isSeeking = false;
    function updateTimeUI() {
      if (!isSeeking) {
        const dur = Math.max(vidA.duration || 0, vidB.duration || 0);
        const cur = Math.max(vidA.currentTime || 0, vidB.currentTime || 0);
        if (isFinite(dur) && dur > 0) {
          seek.value = Math.round(1000 * cur / dur);
          timeLabel.textContent = `${formatTime(cur)} / ${formatTime(dur)}`;
        } else {
          seek.value = 0;
          timeLabel.textContent = `00:00 / 00:00`;
        }
      }
      requestAnimationFrame(updateTimeUI);
    }
    requestAnimationFrame(updateTimeUI);
    
    // Track seeking state
    seek.addEventListener('mousedown', () => { isSeeking = true; });
    seek.addEventListener('mouseup', () => { isSeeking = false; });
    seek.addEventListener('touchstart', () => { isSeeking = true; });
    seek.addEventListener('touchend', () => { isSeeking = false; });

    // Scrub both videos together
    seek.addEventListener('input', () => {
      if (!aReady || !bReady) return;
      const dur = Math.max(vidA.duration || 0, vidB.duration || 0);
      const t = dur * (seek.value / 1000);
      if (isFinite(t) && dur > 0) {
        syncing = false; // Temporarily disable sync during seeking
        vidA.currentTime = t;
        vidB.currentTime = t;
        // Re-enable sync after a brief delay
        setTimeout(() => { if (!vidA.paused) syncing = true; }, 100);
      }
    });

    // Simple sync approach
    function syncClock() {
      if (!syncing) return;
      const t = vidA.currentTime;
      // Only sync if significantly out of sync
      if (Math.abs((vidB.currentTime || 0) - t) > 0.033) {
        vidB.currentTime = t;
      }
      if ('requestVideoFrameCallback' in vidA) {
        vidA.requestVideoFrameCallback(syncClock);
      } else {
        setTimeout(syncClock, 16);
      }
    }

    function startSync() {
      syncing = true;
      if ('requestVideoFrameCallback' in vidA) vidA.requestVideoFrameCallback(syncClock);
      else syncClock();
    }
    function stopSync() { syncing = false; }

    // Load local files via object URLs
    function loadFile(input, videoEl, sideLabel) {
      const f = input.files && input.files[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      // Reset video element
      videoEl.pause();
      videoEl.removeAttribute('src');
      videoEl.load();
      videoEl.src = url;
      videoEl.loop = loop.checked;
      videoEl.muted = true;
      videoEl.playsInline = true;

      videoEl.onloadedmetadata = () => {
        // Update aspect ratio once we have at least one video ready
        const w = videoEl.videoWidth, h = videoEl.videoHeight;
        if (w && h) player.style.aspectRatio = `${w} / ${h}`;
        if (videoEl === vidA) aReady = true; else bReady = true;

        // Warn if dimensions or fps mismatch
        let warn = [];
        if (aReady && bReady) {
          if (vidA.videoWidth !== vidB.videoWidth || vidA.videoHeight !== vidB.videoHeight) {
            warn.push('Resolution mismatch');
          }
          // Crude fps check via frame rate hint, not always available; still helpful.
          const fpsA = vidA.getVideoPlaybackQuality?.().totalVideoFrames / Math.max(vidA.currentTime || 1, 1);
          const fpsB = vidB.getVideoPlaybackQuality?.().totalVideoFrames / Math.max(vidB.currentTime || 1, 1);
          // (We won't rely on this for gating; browsers don't expose true FPS reliably.)
          if (warn.length) {
            status.textContent = 'âš  ' + warn.join(', ');
            status.className = 'bad';
          } else {
            status.textContent = 'âœ“ Ready';
            status.className = 'good';
          }
          playPause.disabled = false;
          // Align starts
          vidA.currentTime = 0; vidB.currentTime = 0;
        }
      };

      videoEl.onerror = () => {
        status.textContent = `Error loading ${sideLabel}. Try MP4 (H.264) or WebM.`;
        status.className = 'bad';
      };
    }

    // Load videos directly from server paths
    function loadServerVideo(path, videoEl, sideLabel) {
      videoEl.pause();
      videoEl.removeAttribute('src');
      videoEl.load();
      videoEl.src = path;
      videoEl.loop = loop.checked;
      videoEl.muted = true;
      videoEl.playsInline = true;

      videoEl.onloadeddata = () => {
        const w = videoEl.videoWidth, h = videoEl.videoHeight;
        if (w && h) player.style.aspectRatio = `${w} / ${h}`;
        if (videoEl === vidA) aReady = true; else bReady = true;

        if (aReady && bReady) {
          status.textContent = 'âœ“ Ready';
          status.className = 'good';
          playPause.disabled = false;
          vidA.currentTime = 0; 
          vidB.currentTime = 0;
          // Update seek bar max based on actual duration
          const dur = Math.max(vidA.duration || 0, vidB.duration || 0);
          if (dur > 0) {
            seek.max = 1000;
            timeLabel.textContent = `00:00 / ${formatTime(dur)}`;
          }
        }
      };

      videoEl.onerror = () => {
        status.textContent = `Error loading ${sideLabel}`;
        status.className = 'bad';
      };
    }

    fileA.addEventListener('change', () => loadFile(fileA, vidA, 'Left (A)'));
    fileB.addEventListener('change', () => loadFile(fileB, vidB, 'Right (B)'));

    // Always use S3 URLs for testing
    const videoBase = 'https://sima-upscale-demo.s3.amazonaws.com/';

    // Track current video sources
    let currentSources = {
      left: 'simaf',
      right: 'resr'
    };

    // Video selection logic
    const videoPairs = {
      'koala_surfing': {
        right: videoBase + 'videos/koala_surfing_resr.mp4',
        left: videoBase + 'videos/koala_surfing_simaq.mp4',
        name: 'Koala Surfing',
        leftModel: 'SimaUpscaleQ',
        rightModel: 'RealESRGAN',
        category: 'quality'
      },
      'ocean_fire': {
        right: videoBase + 'videos/ocean_fire_resr.mp4',
        left: videoBase + 'videos/ocean_fire_simaq.mp4',
        name: 'Ocean Fire',
        leftModel: 'SimaUpscaleQ',
        rightModel: 'RealESRGAN',
        category: 'quality'
      },
      'videoSRC21_07': {
        right: videoBase + 'videos/videoSRC21_07_resr.mp4',
        left: videoBase + 'videos/videoSRC21_07_simaq.mp4',
        name: 'Video SRC21_07',
        leftModel: 'SimaUpscaleQ',
        rightModel: 'RealESRGAN',
        category: 'quality'
      },
      'butterfly_mj': {
        simaf: videoBase + 'fidelity/butterfly_mj_simaf.mp4',
        resr: videoBase + 'fidelity/butterfly_mj_resr.mp4',
        lr: videoBase + 'fidelity/butterfly_mj_lr.mp4',
        right: videoBase + 'fidelity/butterfly_mj_resr.mp4',
        left: videoBase + 'fidelity/butterfly_mj_simaf.mp4',
        name: 'Butterfly MJ',
        leftModel: 'SimaUpscaleF',
        rightModel: 'RealESRGAN',
        category: 'fidelity'
      },
      'snow_scene_veo3': {
        simaf: videoBase + 'fidelity/snow_scene_veo3_simaf.mp4',
        resr: videoBase + 'fidelity/snow_scene_veo3_resr.mp4',
        lr: videoBase + 'fidelity/snow_scene_veo3_lr.mp4',
        right: videoBase + 'fidelity/snow_scene_veo3_resr.mp4',
        left: videoBase + 'fidelity/snow_scene_veo3_simaf.mp4',
        name: 'Snow Scene VEO3',
        leftModel: 'SimaUpscaleF',
        rightModel: 'RealESRGAN',
        category: 'fidelity'
      },
      'car': {
        simaf: videoBase + 'fidelity/car_simaf.mp4',
        resr: videoBase + 'fidelity/car_resr.mp4',
        lr: videoBase + 'fidelity/car_lr.mp4',
        right: videoBase + 'fidelity/car_resr.mp4',
        left: videoBase + 'fidelity/car_simaf.mp4',
        name: 'Car',
        leftModel: 'SimaUpscaleF',
        rightModel: 'RealESRGAN',
        category: 'fidelity'
      },
      'dancing': {
        simaf: videoBase + 'fidelity/dancing_simaf.mp4',
        resr: videoBase + 'fidelity/dancing_resr.mp4',
        lr: videoBase + 'fidelity/dancing_lr.mp4',
        right: videoBase + 'fidelity/dancing_resr.mp4',
        left: videoBase + 'fidelity/dancing_simaf.mp4',
        name: 'Dancing',
        leftModel: 'SimaUpscaleF',
        rightModel: 'RealESRGAN',
        category: 'fidelity'
      },
      'goat': {
        simaf: videoBase + 'fidelity/goat_simaf.mp4',
        resr: videoBase + 'fidelity/goat_resr.mp4',
        lr: videoBase + 'fidelity/goat_lr.mp4',
        right: videoBase + 'fidelity/goat_resr.mp4',
        left: videoBase + 'fidelity/goat_simaf.mp4',
        name: 'Goat',
        leftModel: 'SimaUpscaleF',
        rightModel: 'RealESRGAN',
        category: 'fidelity'
      },
      'deep_codec': {
        right: videoBase + 'deep_codec/standard_codec.mp4',
        left: videoBase + 'deep_codec/deep_codec.mp4',
        name: 'Deep Codec Comparison',
        leftModel: 'Deep Codec',
        rightModel: 'Standard Codec',
        leftMetrics: { psnr: '39.59 dB', bitrate: '216 kbps' },
        rightMetrics: { psnr: '39.12 dB', bitrate: '605 kbps' },
        category: 'codec'
      },
      'deep_codec_waves': {
        right: videoBase + 'deep_codec/standard_codec_waves.mp4',
        left: videoBase + 'deep_codec/deep_codec_waves.mp4',
        name: 'Waves - Deep Codec Comparison',
        leftModel: 'Deep Codec',
        rightModel: 'Standard Codec',
        leftMetrics: { psnr: '34.8 dB', bitrate: '1364 kbps' },
        rightMetrics: { psnr: '33.9 dB', bitrate: '2836 kbps' },
        category: 'codec'
      }
    };

    let currentVideoKey = null;

    function loadVideoPair(videoKey) {
      const pair = videoPairs[videoKey];
      if (!pair) return;
      
      currentVideoKey = videoKey;
      
      // Show/hide toggle buttons and labels based on category
      const togglesEl = document.getElementById('sourceToggles');
      const labelsEl = document.getElementById('videoLabels');
      const metricsEl = document.getElementById('codecMetrics');
      
      if (pair.category === 'fidelity') {
        togglesEl.style.display = '';
        labelsEl.style.display = 'none';
        metricsEl.style.display = 'none';
        // Reset to default sources for fidelity videos
        currentSources.left = 'simaf';
        currentSources.right = 'resr';
        updateToggleButtons();
      } else if (pair.category === 'codec') {
        togglesEl.style.display = 'none';
        labelsEl.style.display = '';
        metricsEl.style.display = '';
        // Update labels and metrics for codec videos
        document.getElementById('leftLabel').textContent = pair.leftModel;
        document.getElementById('rightLabel').textContent = pair.rightModel;
        document.getElementById('leftMetric').innerHTML = 
          `PSNR: <span class="value">${pair.leftMetrics.psnr}</span> | Bitrate: <span class="value">${pair.leftMetrics.bitrate}</span>`;
        document.getElementById('rightMetric').innerHTML = 
          `PSNR: <span class="value">${pair.rightMetrics.psnr}</span> | Bitrate: <span class="value">${pair.rightMetrics.bitrate}</span>`;
      } else {
        togglesEl.style.display = 'none';
        labelsEl.style.display = '';
        metricsEl.style.display = 'none';
        // Update labels for quality videos
        document.getElementById('leftLabel').textContent = pair.leftModel;
        document.getElementById('rightLabel').textContent = pair.rightModel;
      }
      
      // Update title
      const leftLabel = getModelLabel(currentSources.left, pair.category);
      const rightLabel = getModelLabel(currentSources.right, pair.category);
      document.querySelector('h1').textContent = `${leftLabel} vs ${rightLabel} â€” Video Comparison`;
      
      // Reset state
      aReady = false;
      bReady = false;
      syncing = false;
      playPause.textContent = 'Play';
      playPause.disabled = true;
      status.textContent = 'Loading...';
      status.className = '';
      
      // Stop current videos
      vidA.pause();
      vidB.pause();
      
      // Load videos based on current sources or default
      if (pair.category === 'fidelity') {
        const leftVideo = pair[currentSources.left] || pair.left;
        const rightVideo = pair[currentSources.right] || pair.right;
        loadServerVideo(rightVideo, vidA, getModelLabel(currentSources.right, pair.category));
        loadServerVideo(leftVideo, vidB, getModelLabel(currentSources.left, pair.category));
      } else {
        loadServerVideo(pair.right, vidA, pair.rightModel);
        loadServerVideo(pair.left, vidB, pair.leftModel);
      }
    }

    function getModelLabel(source, category) {
      if (source === 'simaf') return 'SimaUpscaleF';
      if (source === 'simaq') return 'SimaUpscaleQ';
      if (source === 'resr') return 'RealESRGAN';
      if (source === 'lr') return 'Input LR';
      return source;
    }


    function updateToggleButtons() {
      document.querySelectorAll('.toggle-btn').forEach(btn => {
        const side = btn.dataset.side;
        const source = btn.dataset.source;
        if (currentSources[side] === source) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // Handle toggle button clicks
    document.querySelectorAll('.toggle-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const side = btn.dataset.side;
        const source = btn.dataset.source;
        const pair = videoPairs[currentVideoKey];
        
        if (!pair || pair.category !== 'fidelity') return;
        if (currentSources[side] === source) return; // Already selected
        
        // Update current source
        currentSources[side] = source;
        updateToggleButtons();
        
        // Update title
        const leftLabel = getModelLabel(currentSources.left, pair.category);
        const rightLabel = getModelLabel(currentSources.right, pair.category);
        document.querySelector('h1').textContent = `${leftLabel} vs ${rightLabel} â€” Video Comparison`;
        
        // Load the new video
        const videoPath = pair[source];
        const videoEl = side === 'left' ? vidB : vidA;
        const wasPlaying = !vidA.paused;
        
        // Stop playback
        if (wasPlaying) {
          vidA.pause();
          vidB.pause();
          stopSync();
          playPause.textContent = 'Play';
        }
        
        // Reset ready state for the side being changed
        if (side === 'left') {
          bReady = false;
        } else {
          aReady = false;
        }
        
        // Load new video
        loadServerVideo(videoPath, videoEl, getModelLabel(source, pair.category));
      });
    });

    // Handle video option clicks
    document.querySelectorAll('.video-option').forEach(option => {
      option.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.video-option').forEach(o => o.classList.remove('active'));
        option.classList.add('active');
        
        // Load the selected video pair
        const videoKey = option.dataset.video;
        loadVideoPair(videoKey);
      });
    });

    // Auto-load the first video on page load
    window.addEventListener('load', () => {
      loadVideoPair('koala_surfing');
    });

    // Controls
    playPause.addEventListener('click', async () => {
      if (!(aReady && bReady)) return;
      if (vidA.paused) {
        try {
          vidB.currentTime = vidA.currentTime;
          await Promise.all([vidA.play(), vidB.play()]);
          startSync();
          playPause.textContent = 'Pause';
        } catch (e) {
          status.textContent = 'Autoplay blocked: click Play again or interact with the page.';
          status.className = 'bad';
        }
      } else {
        vidA.pause(); 
        vidB.pause();
        stopSync();
        playPause.textContent = 'Play';
      }
    });

    rate.addEventListener('change', () => {
      const r = Number(rate.value);
      vidA.playbackRate = r; vidB.playbackRate = r;
    });

    loop.addEventListener('change', () => { 
      vidA.loop = loop.checked; 
      vidB.loop = loop.checked; 
    });
    
    // Simple loop sync
    vidA.addEventListener('seeked', () => {
      if (vidA.loop && vidA.currentTime < 0.5 && !isSeeking) {
        vidB.currentTime = vidA.currentTime;
      }
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); playPause.click(); }
      if (e.code === 'ArrowLeft') { seek.stepDown(10); seek.dispatchEvent(new Event('input')); }
      if (e.code === 'ArrowRight') { seek.stepUp(10); seek.dispatchEvent(new Event('input')); }
    });
  </script>
</body>
</html>
